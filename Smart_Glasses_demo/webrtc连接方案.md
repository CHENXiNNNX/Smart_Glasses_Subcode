1.采用websocekt做信令服务器
(1)服务器架构
- 基于WebSocket协议，监听端口8000
- 采用事件驱动模式，异步处理客户端连接和消息
- 支持多客户端并发连接，每个连接独立管理
- 使用线程池处理消息转发，避免阻塞
(2)房间管理机制
- 房间以唯一标识命名，格式为: room_123456
- 房间最大容量为2个客户端(设备端+APP端)
- 房间创建时设置30秒超时机制，防止单方长期占用
- 房间状态: WAITING(等待配对)、PAIRED(已配对)、TIMEOUT(超时)
(3)客户端连接管理
- 每个WebSocket连接分配唯一的连接ID
- 维护连接状态: CONNECTED(已连接)、JOINED(已加入房间)、PAIRED(已配对)
- 连接断开时自动清理相关房间和配对关系
- 支持断线重连，保持会话状态
(4)消息处理流程
- 接收客户端JSON消息，验证格式和字段完整性
- 根据消息类型(join/leave/offer/answer/ice)进行相应处理
- 消息转发时添加时间戳和路由信息
- 错误消息统一格式，包含错误码和描述信息
- JSON消息统一使用UTF-8文本格式收发，不使用二进制格式
(5)错误码定义
- 1001: 房间已满，无法加入
- 1002: 房间不存在或已过期
- 1003: 消息格式错误
- 1004: 设备ID格式错误
- 1005: 连接超时
- 1006: 对端已离线
- 1007: 服务器内部错误
(6)配对逻辑
- 第一个加入房间的客户端自动成为发起方(offerer)
- 第二个加入房间的客户端自动成为应答方(answerer)
- 配对成功后，服务器向双方发送role消息，包含对端设备ID
- 后续SDP和ICE消息在配对的双方之间透明转发
(7)日志和监控
- 记录所有客户端连接、断开事件
- 记录房间创建、销毁、配对事件
- 记录消息转发统计信息
- 提供简单的Web管理界面，显示当前房间和连接状态
(8)服务器配置参数
- 监听端口: 8000 (可配置)
- 房间超时时间: 30秒 (可配置)
- 最大并发连接数: 1000 (可配置)
- 消息队列大小: 10000 (可配置)
- 日志级别: INFO (可配置)

2.明确的json消息格式(设备端)
注意：所有JSON消息均采用UTF-8文本格式传输，不使用二进制格式
(1)加入房间
{
  "type": "join",
  "device_id": "glasses_xxx"  # xxx代表唯一标识，以后会使用mac地址作为标识，现在测试的时候暂定为123456
  "from":"glasses_xxx"  # xxx代表唯一标识，以后会使用mac地址作为标识，现在测试的时候暂定为123456
  "to":"server"
  "time": 国际标准时间(1970年开始)，以微秒为单位
}
(2)离开房间
{
  "type": "leave",
  "device_id": "glasses_xxx"  # xxx代表唯一标识，以后会使用mac地址作为标识，现在测试的时候暂定为123456
  "from":"glasses_xxx"  # xxx代表唯一标识，以后会使用mac地址作为标识，现在测试的时候暂定为123456
  "to":"server"
  "time": 国际标准时间(1970年开始)，以微秒为单位
}
(3)sdp发送
{
  "type": "offer",
  "device_id": "glasses_xxx"  # xxx代表唯一标识，以后会使用mac地址作为标识，现在测试的时候暂定为123456
  "from":"glasses_xxx"  # xxx代表唯一标识，以后会使用mac地址作为标识，现在测试的时候暂定为123456
  "to":"app_xxx"
  "data":{}
  "time": 国际标准时间(1970年开始)，以微秒为单位
}
(4)sdp应答
{
  "type": "answer",
  "device_id": "glasses_xxx"  # xxx代表唯一标识，以后会使用mac地址作为标识，现在测试的时候暂定为123456
  "from":"glasses_xxx"  # xxx代表唯一标识，以后会使用mac地址作为标识，现在测试的时候暂定为123456
  "to":"app_xxx"
  "data":{}
  "time": 国际标准时间(1970年开始)，以微秒为单位
}
(5)ice信息
{
  "type": "ice",
  "device_id": "glasses_xxx"  # xxx代表唯一标识，以后会使用mac地址作为标识，现在测试的时候暂定为123456
  "from":"glasses_xxx"  # xxx代表唯一标识，以后会使用mac地址作为标识，现在测试的时候暂定为123456
  "to":"app_xxx"
  "data":{}
  "time": 国际标准时间(1970年开始)，以微秒为单位
}
(6)角色信息
{
  "type": "role",
  "device_id": "app_xxx"  # xxx代表唯一标识，以后会使用mac地址作为标识，现在测试的时候暂定为123456
  "from":"server"  # xxx代表唯一标识，以后会使用mac地址作为标识，现在测试的时候暂定为123456
  "to":"glasses_xxx"
  "data":{}
  "time": 国际标准时间(1970年开始)，以微秒为单位
}
(7)错误信息
{
  "type": "error",
  "device_id": "glasses_xxx"  # xxx代表唯一标识，以后会使用mac地址作为标识，现在测试的时候暂定为123456
  "from":"server"
  "to":"glasses_xxx"
  "data":{"error_code": 错误码, "error_message": "错误描述信息"}
  "time": 国际标准时间(1970年开始)，以微秒为单位
}

3.明确的json消息格式(APP端)
注意：所有JSON消息均采用UTF-8文本格式传输，不使用二进制格式
(1)加入房间
{
  "type": "join",
  "device_id": "app_xxx"  # xxx代表唯一标识，以后会使用mac地址作为标识，现在测试的时候暂定为123456
  "from":"app_xxx"  # xxx代表唯一标识，以后会使用mac地址作为标识，现在测试的时候暂定为123456
  "to":"server"
  "time": 国际标准时间(1970年开始)，以微秒为单位
}
(2)离开房间
{
  "type": "leave",
  "device_id": "app_xxx"  # xxx代表唯一标识，以后会使用mac地址作为标识，现在测试的时候暂定为123456
  "from":"app_xxx"  # xxx代表唯一标识，以后会使用mac地址作为标识，现在测试的时候暂定为123456
  "to":"server"
  "time": 国际标准时间(1970年开始)，以微秒为单位
}
(3)sdp发送
{
  "type": "offer",
  "device_id": "app_xxx"  # xxx代表唯一标识，以后会使用mac地址作为标识，现在测试的时候暂定为123456
  "from":"app_xxx"  # xxx代表唯一标识，以后会使用mac地址作为标识，现在测试的时候暂定为123456
  "to":"glasses_xxx"
  "data":{}
  "time": 国际标准时间(1970年开始)，以微秒为单位
}
(4)sdp应答
{
  "type": "answer",
  "device_id": "app_xxx"  # xxx代表唯一标识，以后会使用mac地址作为标识，现在测试的时候暂定为123456
  "from":"app_xxx"  # xxx代表唯一标识，以后会使用mac地址作为标识，现在测试的时候暂定为123456
  "to":"glasses_xxx"
  "data":{}
  "time": 国际标准时间(1970年开始)，以微秒为单位
}
(5)ice信息
{
  "type": "ice",
  "device_id": "app_xxx"  # xxx代表唯一标识，以后会使用mac地址作为标识，现在测试的时候暂定为123456
  "from":"app_xxx"  # xxx代表唯一标识，以后会使用mac地址作为标识，现在测试的时候暂定为123456
  "to":"glasses_xxx"
  "data":{}
  "time": 国际标准时间(1970年开始)，以微秒为单位
}
(6)角色信息
{
  "type": "role",
  "device_id": "app_xxx"  # xxx代表唯一标识，以后会使用mac地址作为标识，现在测试的时候暂定为123456
  "from":"server"  # xxx代表唯一标识，以后会使用mac地址作为标识，现在测试的时候暂定为123456
  "to":"app_xxx"
  "data":{}
  "time": 国际标准时间(1970年开始)，以微秒为单位
}
(7)错误信息
{
  "type": "error",
  "device_id": "app_xxx"  # xxx代表唯一标识，以后会使用mac地址作为标识，现在测试的时候暂定为123456
  "from":"server"
  "to":"app_xxx"
  "data":{"error_code": 错误码, "error_message": "错误描述信息"}
  "time": 国际标准时间(1970年开始)，以微秒为单位
}

4.音视频传输配置
(1)音频收发
-opus格式
-16000hz
-实时的双向音频通信

(2)视频发送
-h264格式
-实时的设备端到APP端的单向发送视频

5.webrtc配置
(1)实现数据通道，音频收发，视频发送的接口
(2)可以选择开关这三个接口，通过在结构体里面配置
(3)通过现有的视频接口实现设备端到APP端的实时单向h264视频发送
(4)实现实时音频收发功能
(5)实现实时音视频流同步

6.功能:
(1)webrtc的连接过程分为三个端，设备端，服务器，APP端
(2)双向音频+单向视频，其中视频为设备端到APP端的单向发送
(3)信令服务器会根据双方的唯一标识规划房间，然后让双端加入，进行一对一配对，房间名为双方相同的唯一标识
器规定，双端不干涉，在双方都退出房间之后，会清除房间，等待下一次配对
(4)设备端和对端在ws连接之前会分配了连接标识了，服务器不用管，只需针对标识相同的进行配对就可以了，由于是测试阶段，
设备端唯一标识先固定为glasses_123456，APP端也已经被固定为app_123456，其中123456就是它们的唯一标识，后续会换成设
备端的mac地址，并会在连接信令服务器在本地进行规划设定了，服务端不干涉双端配置，只关注相同唯一标识进行配对
(5)谁先进入房间谁就作为发起方，后进入房间的作为接收方,也就是当一方先连接ws信令服务器后，服务器会基于一方的唯一标
识建立房间，然后将其分配在房间里面，此时房间会保持30秒，当另一方在30秒内没有根据房间号进行对应加入房间的话，此时
服务器会踢掉房间内的人，同时销毁房间
(6)json消息中要附带时间戳，时间戳用国际标准时间戳(1970年开始的那个)，并使用微秒计数
(7)当双端都已经成功加入房间配对后，服务器会分别下发对端的id信息,即设备端收到app_id，APP端收到device_id,双端则会记
录对端设备信息



