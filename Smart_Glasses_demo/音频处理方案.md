### 音频系统架构图
┌─────────────────────────────────────────────────────────┐
│                    音频系统 (audio_system_t)             │
├─────────────────────┬───────────────────────────────────┤
│  核心控制模块         │       功能模块                     │
│                     │                                   │
│  ┌───────────────┐  │  ┌─────────────┐  ┌─────────────┐ │
│  │ 模式管理       │  │  │  音频采集    │  │  音频播放    │ │
│  └───────────────┘  │  └─────────────┘  └─────────────┘ │
│                     │                                   │
│  ┌───────────────┐  │  ┌─────────────┐  ┌─────────────┐ │
│  │ 参数配置       │  │  │  Opus编解码  │  │  音频文件IO  │ │
│  └───────────────┘  │  └─────────────┘  └─────────────┘ │
│                     │                                   │
│  ┌───────────────┐  │  ┌─────────────┐                  │
│  │ 错误处理       │  │  │  二进制协议   │                  │
│  └───────────────┘  │  └─────────────┘                  │
└─────────────────────┴───────────────────────────────────┘
          │                      │
          ▼                      ▼
┌─────────────────┐    ┌───────────────────────────┐
│ AI对话模块       │    │ WebRTC实时通信模块         │
└─────────────────┘    └───────────────────────────┘

### 音频处理器的复用
1. AI对话和webrtc的实时通信复用同一个音频处理器

### 音频状态枚举
1. 枚举类型
typedef enum {
    AUDIO_MODE_NONE = 0,
    AUDIO_MODE_AI,
    AUDIO_MODE_WEBRTC,
} audio_mode_t;
2. 状态功能
    - AUDIO_MODE_NONE: 无音频模式
    - AUDIO_MODE_AI: AI对话模式
    - AUDIO_MODE_WEBRTC: webrtc实时通信模式
其中的AI对话模式和webrtc的实时通信模式下，音频处理器的功能如下：
    - AI对话模式：用于处理AI对话的音频，包括语音识别、语音合成等功能
    - webrtc实时通信模式：用于处理webrtc实时通信的音频，包括音频采集、编码、解码、播放等功能
    - 在AI对话模式和webrtc实时通信模式下，音频处理器的功能是互斥的，在同一时间内，音频处理器只为一方服务
具体的情况可以看当前目录下的智能眼镜软件设计方案

### 音频错误类型枚举
1. 枚举类型
typedef enum {
    AUDIO_ERROR_NONE = 0,
    AUDIO_ERROR_INITIALIZE_FAILED,
    AUDIO_ERROR_DEVICE_NOT_FOUND,
    AUDIO_ERROR_STREAM_OPEN_FAILED,
    AUDIO_ERROR_STREAM_START_FAILED,
    AUDIO_ERROR_ENCODE_FAILED,
    AUDIO_ERROR_DECODE_FAILED,
    AUDIO_ERROR_MODE_CONFLICT,
    AUDIO_ERROR_INVALID_PARAM,
    AUDIO_ERROR_MEMORY_ALLOC_FAILED
} audio_error_t;
2. 错误功能
    - AUDIO_ERROR_NONE: 无错误
    - AUDIO_ERROR_INITIALIZE_FAILED: 初始化失败
    - AUDIO_ERROR_DEVICE_NOT_FOUND: 设备未找到
    - AUDIO_ERROR_STREAM_OPEN_FAILED: 流打开失败
    - AUDIO_ERROR_STREAM_START_FAILED: 流启动失败
    - AUDIO_ERROR_ENCODE_FAILED: 编码失败
    - AUDIO_ERROR_DECODE_FAILED: 解码失败
    - AUDIO_ERROR_MODE_CONFLICT: 模式冲突
    - AUDIO_ERROR_INVALID_PARAM: 无效参数
    - AUDIO_ERROR_MEMORY_ALLOC_FAILED: 内存分配失败

### 统一结构体管理audio_system_t
1. 结构体定义
typedef struct {
    // 音频参数
    int sample_rate;
    int channels;
    int frame_duration_ms;

    // 编解码器相关
    OpusEncoder* encoder;
    OpusDecoder* decoder;

    // 录音相关
    std::queue<std::vector<int16_t>> recordedAudioQueue;  // 录音队列
    std::mutex recordedAudioMutex;   // 录音队列互斥锁
    std::condition_variable recordedAudioCV; // 录音条件变量
    PaStream* recordStream;          // 录音流
    bool isRecording;                // 录音状态标志
    
    // 播放相关
    std::queue<std::vector<int16_t>> playbackQueue;       // 播放队列
    std::mutex playbackMutex;        // 播放队列互斥锁
    PaStream* playbackStream;        // 播放流
    bool isPlaying;                  // 播放状态标志

    // 当前音频模式
    audio_mode_t current_mode;
    ...
} audio_system_t;
2. 功能
    - 用于管理音频系统的状态和功能
    - 包含一个audio_mode_t类型的成员变量audio_mode，用于表示当前的音频模式
    - 可以根据audio_mode的值，来判断当前音频系统的状态和功能
    - 可以通过设置audio_mode的值，来切换音频系统的状态和功能

### 接口定义
1. 初始化音频系统
```c
// 初始化函数
audio_error_t audio_system_init(audio_system_t *audio_system);
```
2. 释放音频系统
```c
// 释放函数
audio_error_t audio_system_deinit(audio_system_t *audio_system);
```
3. 设置音频模式
```c
// 设置音频模式
audio_error_t set_audio_mode(audio_system_t *audio_system, audio_mode_t mode);
```
4. 获取当前模式
```c
// 获取当前模式
audio_mode_t get_current_mode(audio_system_t *audio_system);
```
5. 开始录音
```c
// 开始录音
audio_error_t start_recording(audio_system_t *audio_system);
```
6. 停止录音
```c
// 停止录音
audio_error_t stop_recording(audio_system_t *audio_system);
```
7. 清空录音队列
```c
// 清空录音队列
audio_error_t clear_recording_queue(audio_system_t *audio_system);
```
8. 开始播放
```c
// 开始播放
audio_error_t start_playback(audio_system_t *audio_system);
```
9. 停止播放
```c
// 停止播放函数
audio_error_t stop_playback(audio_system_t *audio_system);
```
10. 清空播放队列
```c
// 清空播放队列
audio_error_t clear_playback_queue(audio_system_t *audio_system);
```
11. 初始化编码器、解码器
```c
// 初始化编码器、解码器
audio_error_t init_opus_codec(audio_system_t *audio_system);
```
12. 编码opus函数
```c
// 编码opus
audio_error_t encode_opus(audio_system_t *audio_system, uint8_t *input, size_t input_size, uint8_t *output, size_t *output_size);
```
13. 解码opus
```c
// 解码opus
audio_error_t decode_opus(audio_system_t *audio_system, uint8_t *input, size_t input_size, uint8_t *output, size_t *output_size);
```
14. 释放 Opus 相关资源 编码器、解码器
```c
// 释放 Opus 相关资源 编码器、解码器
audio_error_t release_opus_codec(audio_system_t *audio_system);
```
15. 保存录音后的音频文件(暂留空实现)
```c
// 保存音频文件
audio_error_t save_audio(audio_system_t *audio_system, const char *file_path);
```
16. 其他函数




