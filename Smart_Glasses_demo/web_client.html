<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ™ºèƒ½çœ¼é•œ - Webæ¥æ”¶ç«¯</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }

        .container {
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            padding: 30px;
            max-width: 800px;
            width: 100%;
            margin-bottom: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .header h1 {
            color: #333;
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .header p {
            color: #666;
            font-size: 1.1em;
        }

        .status-panel {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
            border-left: 4px solid #007bff;
        }

        .status-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            padding: 8px 0;
        }

        .status-item:last-child {
            margin-bottom: 0;
        }

        .status-label {
            font-weight: 600;
            color: #495057;
        }

        .status-value {
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.9em;
            font-weight: 500;
        }

        .status-disconnected {
            background: #f8d7da;
            color: #721c24;
        }

        .status-connecting {
            background: #fff3cd;
            color: #856404;
        }

        .status-connected {
            background: #d4edda;
            color: #155724;
        }

        .control-panel {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 1em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .btn-primary {
            background: linear-gradient(135deg, #007bff, #0056b3);
            color: white;
        }

        .btn-success {
            background: linear-gradient(135deg, #28a745, #1e7e34);
            color: white;
        }

        .btn-danger {
            background: linear-gradient(135deg, #dc3545, #c82333);
            color: white;
        }

        .btn-warning {
            background: linear-gradient(135deg, #ffc107, #e0a800);
            color: #212529;
        }

        .message-panel {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .message-input {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }

        .message-input input {
            flex: 1;
            padding: 12px;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            font-size: 1em;
            transition: border-color 0.3s ease;
        }

        .message-input input:focus {
            outline: none;
            border-color: #007bff;
        }

        .log-container {
            background: #1a1a1a;
            color: #00ff00;
            font-family: 'Courier New', monospace;
            padding: 20px;
            border-radius: 10px;
            height: 300px;
            overflow-y: auto;
            font-size: 0.9em;
            line-height: 1.4;
        }

        .log-container::-webkit-scrollbar {
            width: 8px;
        }

        .log-container::-webkit-scrollbar-track {
            background: #2a2a2a;
            border-radius: 4px;
        }

        .log-container::-webkit-scrollbar-thumb {
            background: #555;
            border-radius: 4px;
        }

        .log-container::-webkit-scrollbar-thumb:hover {
            background: #777;
        }

        .log-entry {
            margin-bottom: 5px;
            word-wrap: break-word;
        }

        .log-timestamp {
            color: #888;
        }

        .log-info {
            color: #00ff00;
        }

        .log-warn {
            color: #ffff00;
        }

        .log-error {
            color: #ff4444;
        }

        .log-webrtc {
            color: #00bfff;
        }

        .footer {
            text-align: center;
            color: white;
            margin-top: 20px;
            opacity: 0.8;
        }

        @media (max-width: 768px) {
            .container {
                padding: 20px;
                margin: 10px;
            }

            .header h1 {
                font-size: 2em;
            }

            .control-panel {
                grid-template-columns: 1fr;
            }

            .message-input {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ•¶ï¸ æ™ºèƒ½çœ¼é•œæ¥æ”¶ç«¯</h1>
            <p>WebRTCè§†é¢‘é€šè¯å’Œæ•°æ®ä¼ è¾“æµ‹è¯•</p>
        </div>

        <div class="status-panel">
            <div class="status-item">
                <span class="status-label">WebSocketçŠ¶æ€:</span>
                <span class="status-value status-disconnected" id="wsStatus">æœªè¿æ¥</span>
            </div>
            <div class="status-item">
                <span class="status-label">WebRTCçŠ¶æ€:</span>
                <span class="status-value status-disconnected" id="rtcStatus">æœªè¿æ¥</span>
            </div>
            <div class="status-item">
                <span class="status-label">è®¾å¤‡ID:</span>
                <span class="status-value" id="deviceId">app_123456</span>
            </div>
            <div class="status-item">
                <span class="status-label">å¯¹ç«¯è®¾å¤‡:</span>
                <span class="status-value" id="peerDevice">æœªè¿æ¥</span>
            </div>
            <div class="status-item">
                <span class="status-label">è§’è‰²:</span>
                <span class="status-value" id="role">æœªåˆ†é…</span>
            </div>
        </div>

        <div class="control-panel">
            <button class="btn btn-primary" id="connectBtn" onclick="connectToServer()">è¿æ¥æœåŠ¡å™¨</button>
            <button class="btn btn-success" id="joinBtn" onclick="joinRoom()" disabled>åŠ å…¥æˆ¿é—´</button>
            <button class="btn btn-warning" id="leaveBtn" onclick="leaveRoom()" disabled>ç¦»å¼€æˆ¿é—´</button>
            <button class="btn btn-danger" id="disconnectBtn" onclick="disconnectFromServer()" disabled>æ–­å¼€è¿æ¥</button>
        </div>

        <div class="message-panel">
            <h3>ğŸ’¬ æ•°æ®é€šé“æ¶ˆæ¯</h3>
            <div class="message-input">
                <input type="text" id="messageInput" placeholder="è¾“å…¥è¦å‘é€çš„æ¶ˆæ¯..." disabled>
                <button class="btn btn-primary" onclick="sendMessage()" disabled id="sendBtn">å‘é€</button>
            </div>
        </div>

        <div class="log-container" id="logContainer">
            <div class="log-entry log-info">
                <span class="log-timestamp">[ç³»ç»Ÿ]</span> é¡µé¢åŠ è½½å®Œæˆï¼Œç­‰å¾…è¿æ¥...
            </div>
        </div>
    </div>

    <div class="footer">
        <p>Smart Glasses WebRTC Client v1.0</p>
    </div>

    <script>
        // å…¨å±€å˜é‡
        const DEVICE_ID = 'app_123456';
        const SERVER_URL = 'ws://localhost:8000';
        
        let ws = null;
        let pc = null;
        let dataChannel = null;
        let connectionStatus = 'disconnected';
        let peerDeviceId = '';
        let role = '';

        // WebRTCé…ç½®
        const rtcConfig = {
            iceServers: [
                // { urls: 'stun:stun.l.google.com:19302' }
            ]
        };

        // æ—¥å¿—å‡½æ•°
        function log(message, type = 'info') {
            const logContainer = document.getElementById('logContainer');
            const timestamp = new Date().toLocaleTimeString();
            const logEntry = document.createElement('div');
            logEntry.className = `log-entry log-${type}`;
            logEntry.innerHTML = `<span class="log-timestamp">[${timestamp}]</span> ${message}`;
            logContainer.appendChild(logEntry);
            logContainer.scrollTop = logContainer.scrollHeight;
        }

        // æ›´æ–°çŠ¶æ€æ˜¾ç¤º
        function updateStatus() {
            document.getElementById('wsStatus').textContent = getWSStatusText();
            document.getElementById('wsStatus').className = `status-value ${getWSStatusClass()}`;
            
            document.getElementById('rtcStatus').textContent = getRTCStatusText();
            document.getElementById('rtcStatus').className = `status-value ${getRTCStatusClass()}`;
            
            document.getElementById('peerDevice').textContent = peerDeviceId || 'æœªè¿æ¥';
            document.getElementById('role').textContent = role || 'æœªåˆ†é…';

            // æ›´æ–°æŒ‰é’®çŠ¶æ€
            updateButtonStates();
        }

        function getWSStatusText() {
            if (!ws) return 'æœªè¿æ¥';
            switch (ws.readyState) {
                case WebSocket.CONNECTING: return 'è¿æ¥ä¸­';
                case WebSocket.OPEN: return connectionStatus === 'paired' ? 'å·²é…å¯¹' : 
                                           connectionStatus === 'joined' ? 'å·²åŠ å…¥æˆ¿é—´' : 'å·²è¿æ¥';
                case WebSocket.CLOSING: return 'æ–­å¼€ä¸­';
                case WebSocket.CLOSED: return 'å·²æ–­å¼€';
                default: return 'æœªçŸ¥';
            }
        }

        function getWSStatusClass() {
            if (!ws) return 'status-disconnected';
            switch (ws.readyState) {
                case WebSocket.CONNECTING: return 'status-connecting';
                case WebSocket.OPEN: return 'status-connected';
                default: return 'status-disconnected';
            }
        }

        function getRTCStatusText() {
            if (!pc) return 'æœªåˆ›å»º';
            switch (pc.connectionState) {
                case 'new': return 'æ–°å»º';
                case 'connecting': return 'è¿æ¥ä¸­';
                case 'connected': return 'å·²è¿æ¥';
                case 'disconnected': return 'å·²æ–­å¼€';
                case 'failed': return 'è¿æ¥å¤±è´¥';
                case 'closed': return 'å·²å…³é—­';
                default: return 'æœªçŸ¥';
            }
        }

        function getRTCStatusClass() {
            if (!pc) return 'status-disconnected';
            switch (pc.connectionState) {
                case 'connecting': return 'status-connecting';
                case 'connected': return 'status-connected';
                default: return 'status-disconnected';
            }
        }

        function updateButtonStates() {
            const isConnected = ws && ws.readyState === WebSocket.OPEN;
            const isJoined = connectionStatus === 'joined' || connectionStatus === 'paired';
            const isPaired = connectionStatus === 'paired';
            const isDataChannelOpen = dataChannel && dataChannel.readyState === 'open';

            document.getElementById('connectBtn').disabled = isConnected;
            document.getElementById('joinBtn').disabled = !isConnected || isJoined;
            document.getElementById('leaveBtn').disabled = !isJoined;
            document.getElementById('disconnectBtn').disabled = !isConnected;
            document.getElementById('messageInput').disabled = !isDataChannelOpen;
            document.getElementById('sendBtn').disabled = !isDataChannelOpen;
        }

        // WebSocketè¿æ¥
        function connectToServer() {
            if (ws && ws.readyState === WebSocket.OPEN) {
                log('å·²ç»è¿æ¥åˆ°æœåŠ¡å™¨', 'warn');
                return;
            }

            log(`æ­£åœ¨è¿æ¥åˆ°æœåŠ¡å™¨: ${SERVER_URL}`, 'info');
            ws = new WebSocket(SERVER_URL);

            ws.onopen = function() {
                log('WebSocketè¿æ¥æˆåŠŸ', 'info');
                connectionStatus = 'connected';
                updateStatus();
            };

            ws.onmessage = function(event) {
                try {
                    const message = JSON.parse(event.data);
                    handleWebSocketMessage(message);
                } catch (error) {
                    log(`è§£ææ¶ˆæ¯å¤±è´¥: ${error.message}`, 'error');
                }
            };

            ws.onclose = function() {
                log('WebSocketè¿æ¥å·²å…³é—­', 'warn');
                connectionStatus = 'disconnected';
                peerDeviceId = '';
                role = '';
                updateStatus();
            };

            ws.onerror = function(error) {
                log(`WebSocketé”™è¯¯: ${error}`, 'error');
            };
        }

        // å¤„ç†WebSocketæ¶ˆæ¯
        function handleWebSocketMessage(message) {
            log(`æ”¶åˆ°æ¶ˆæ¯: ${message.type} from ${message.from}`, 'info');

            switch (message.type) {
                case 'role':
                    handleRoleMessage(message);
                    break;
                case 'offer':
                    handleOfferMessage(message);
                    break;
                case 'answer':
                    handleAnswerMessage(message);
                    break;
                case 'ice':
                    handleIceMessage(message);
                    break;
                case 'error':
                    handleErrorMessage(message);
                    break;
                default:
                    log(`æœªçŸ¥æ¶ˆæ¯ç±»å‹: ${message.type}`, 'warn');
            }
        }

        // å¤„ç†è§’è‰²åˆ†é…æ¶ˆæ¯
        function handleRoleMessage(message) {
            if (message.data && message.data.peer_device_id) {
                peerDeviceId = message.data.peer_device_id;
            }
            if (message.data && message.data.role) {
                role = message.data.role;
            }
            
            connectionStatus = 'paired';
            log(`é…å¯¹æˆåŠŸ - å¯¹ç«¯è®¾å¤‡: ${peerDeviceId}, è§’è‰²: ${role}`, 'info');
            updateStatus();

            // åˆ›å»ºWebRTCè¿æ¥
            createPeerConnection();
        }

        // åˆ›å»ºWebRTCè¿æ¥
        function createPeerConnection() {
            try {
                pc = new RTCPeerConnection(rtcConfig);
                log('åˆ›å»ºWebRTC PeerConnection', 'webrtc');

                // ICEå€™é€‰äº‹ä»¶
                pc.onicecandidate = function(event) {
                    if (event.candidate) {
                        log(`ç”Ÿæˆæœ¬åœ°ICEå€™é€‰: ${event.candidate.candidate}`, 'webrtc');
                        sendIceCandidate(event.candidate);
                    }
                };

                // è¿æ¥çŠ¶æ€å˜åŒ–
                pc.onconnectionstatechange = function() {
                    log(`WebRTCè¿æ¥çŠ¶æ€: ${pc.connectionState}`, 'webrtc');
                    updateStatus();
                };

                // æ•°æ®é€šé“äº‹ä»¶ï¼ˆåº”ç­”æ–¹æ¥æ”¶ï¼‰
                pc.ondatachannel = function(event) {
                    const channel = event.channel;
                    log(`æ”¶åˆ°è¿œç¨‹DataChannel: ${channel.label}`, 'webrtc');
                    setupDataChannel(channel);
                };

                // å¦‚æœæ˜¯å‘èµ·æ–¹ï¼Œåˆ›å»ºæ•°æ®é€šé“
                if (role === 'offerer') {
                    log('ä½œä¸ºå‘èµ·æ–¹åˆ›å»ºDataChannel', 'webrtc');
                    dataChannel = pc.createDataChannel('test');
                    setupDataChannel(dataChannel);
                    
                    // åˆ›å»ºå¹¶å‘é€offer
                    pc.createOffer().then(function(offer) {
                        return pc.setLocalDescription(offer);
                    }).then(function() {
                        log('å‘é€SDP Offer', 'webrtc');
                        sendOffer(pc.localDescription.sdp);
                    }).catch(function(error) {
                        log(`åˆ›å»ºOfferå¤±è´¥: ${error}`, 'error');
                    });
                }

            } catch (error) {
                log(`åˆ›å»ºWebRTCè¿æ¥å¤±è´¥: ${error}`, 'error');
            }
        }

        // è®¾ç½®æ•°æ®é€šé“
        function setupDataChannel(channel) {
            dataChannel = channel;

            dataChannel.onopen = function() {
                log('DataChannelè¿æ¥å·²æ‰“å¼€', 'webrtc');
                updateStatus();
                
                // å‘é€æµ‹è¯•æ¶ˆæ¯
                if (role === 'offerer') {
                    const testMessage = 'Hello from web client!';
                    dataChannel.send(testMessage);
                    log(`å‘é€æ¶ˆæ¯: ${testMessage}`, 'info');
                }
            };

            dataChannel.onmessage = function(event) {
                log(`æ”¶åˆ°DataChannelæ¶ˆæ¯: ${event.data}`, 'info');
                
                // å¦‚æœæ˜¯åº”ç­”æ–¹ï¼Œå›å¤æ¶ˆæ¯
                if (role === 'answerer') {
                    const reply = `Reply from web: ${event.data}`;
                    dataChannel.send(reply);
                    log(`å›å¤æ¶ˆæ¯: ${reply}`, 'info');
                }
            };

            dataChannel.onclose = function() {
                log('DataChannelå·²å…³é—­', 'warn');
                updateStatus();
            };

            dataChannel.onerror = function(error) {
                log(`DataChannelé”™è¯¯: ${error}`, 'error');
            };
        }

        // å¤„ç†SDP Offer
        function handleOfferMessage(message) {
            if (!pc || !message.data || !message.data.sdp) return;

            log('æ”¶åˆ°SDP Offer', 'webrtc');
            
            const offer = new RTCSessionDescription({
                type: 'offer',
                sdp: message.data.sdp
            });

            pc.setRemoteDescription(offer).then(function() {
                log('è®¾ç½®è¿œç¨‹SDP OfferæˆåŠŸ', 'webrtc');
                return pc.createAnswer();
            }).then(function(answer) {
                return pc.setLocalDescription(answer);
            }).then(function() {
                log('å‘é€SDP Answer', 'webrtc');
                sendAnswer(pc.localDescription.sdp);
            }).catch(function(error) {
                log(`å¤„ç†Offerå¤±è´¥: ${error}`, 'error');
            });
        }

        // å¤„ç†SDP Answer
        function handleAnswerMessage(message) {
            if (!pc || !message.data || !message.data.sdp) return;

            log('æ”¶åˆ°SDP Answer', 'webrtc');
            
            const answer = new RTCSessionDescription({
                type: 'answer',
                sdp: message.data.sdp
            });

            pc.setRemoteDescription(answer).then(function() {
                log('è®¾ç½®è¿œç¨‹SDP AnsweræˆåŠŸ', 'webrtc');
            }).catch(function(error) {
                log(`è®¾ç½®è¿œç¨‹SDPå¤±è´¥: ${error}`, 'error');
            });
        }

        // å¤„ç†ICEå€™é€‰
        function handleIceMessage(message) {
            if (!pc || !message.data || !message.data.candidate) return;

            log('æ”¶åˆ°ICEå€™é€‰', 'webrtc');
            
            try {
                const candidate = new RTCIceCandidate({
                    candidate: message.data.candidate,
                    sdpMLineIndex: 0,
                    sdpMid: '0'
                });
                
                pc.addIceCandidate(candidate).then(function() {
                    log('æ·»åŠ è¿œç¨‹ICEå€™é€‰æˆåŠŸ', 'webrtc');
                }).catch(function(error) {
                    log(`æ·»åŠ ICEå€™é€‰å¤±è´¥: ${error}`, 'error');
                });
            } catch (error) {
                log(`è§£æICEå€™é€‰å¤±è´¥: ${error}`, 'error');
            }
        }

        // å¤„ç†é”™è¯¯æ¶ˆæ¯
        function handleErrorMessage(message) {
            if (message.data) {
                const errorCode = message.data.error_code || 'unknown';
                const errorMessage = message.data.error_message || 'æœªçŸ¥é”™è¯¯';
                log(`æœåŠ¡å™¨é”™è¯¯ [${errorCode}]: ${errorMessage}`, 'error');
            }
        }

        // å‘é€æ¶ˆæ¯åˆ°æœåŠ¡å™¨
        function sendToServer(message) {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify(message));
                return true;
            }
            log('WebSocketæœªè¿æ¥ï¼Œæ— æ³•å‘é€æ¶ˆæ¯', 'error');
            return false;
        }

        // åŠ å…¥æˆ¿é—´
        function joinRoom() {
            const message = {
                type: 'join',
                device_id: DEVICE_ID,
                from: DEVICE_ID,
                to: 'server',
                time: Date.now() * 1000
            };
            
            if (sendToServer(message)) {
                log('å‘é€åŠ å…¥æˆ¿é—´æ¶ˆæ¯', 'info');
                connectionStatus = 'joined';
                updateStatus();
            }
        }

        // ç¦»å¼€æˆ¿é—´
        function leaveRoom() {
            const message = {
                type: 'leave',
                device_id: DEVICE_ID,
                from: DEVICE_ID,
                to: 'server',
                time: Date.now() * 1000
            };
            
            if (sendToServer(message)) {
                log('å‘é€ç¦»å¼€æˆ¿é—´æ¶ˆæ¯', 'info');
                connectionStatus = 'connected';
                peerDeviceId = '';
                role = '';
                
                // å…³é—­WebRTCè¿æ¥
                if (pc) {
                    pc.close();
                    pc = null;
                }
                if (dataChannel) {
                    dataChannel.close();
                    dataChannel = null;
                }
                
                updateStatus();
            }
        }

        // æ–­å¼€è¿æ¥
        function disconnectFromServer() {
            if (ws) {
                ws.close();
                ws = null;
            }
            
            if (pc) {
                pc.close();
                pc = null;
            }
            
            if (dataChannel) {
                dataChannel.close();
                dataChannel = null;
            }
            
            connectionStatus = 'disconnected';
            peerDeviceId = '';
            role = '';
            updateStatus();
            
            log('å·²æ–­å¼€è¿æ¥', 'info');
        }

        // å‘é€SDP Offer
        function sendOffer(sdp) {
            const message = {
                type: 'offer',
                device_id: DEVICE_ID,
                from: DEVICE_ID,
                to: peerDeviceId,
                data: { sdp: sdp },
                time: Date.now() * 1000
            };
            sendToServer(message);
        }

        // å‘é€SDP Answer
        function sendAnswer(sdp) {
            const message = {
                type: 'answer',
                device_id: DEVICE_ID,
                from: DEVICE_ID,
                to: peerDeviceId,
                data: { sdp: sdp },
                time: Date.now() * 1000
            };
            sendToServer(message);
        }

        // å‘é€ICEå€™é€‰
        function sendIceCandidate(candidate) {
            const message = {
                type: 'ice',
                device_id: DEVICE_ID,
                from: DEVICE_ID,
                to: peerDeviceId,
                data: { candidate: candidate.candidate },
                time: Date.now() * 1000
            };
            sendToServer(message);
        }

        // å‘é€DataChannelæ¶ˆæ¯
        function sendMessage() {
            const input = document.getElementById('messageInput');
            const message = input.value.trim();
            
            if (!message) {
                log('è¯·è¾“å…¥æ¶ˆæ¯å†…å®¹', 'warn');
                return;
            }
            
            if (dataChannel && dataChannel.readyState === 'open') {
                dataChannel.send(message);
                log(`å‘é€æ¶ˆæ¯: ${message}`, 'info');
                input.value = '';
            } else {
                log('DataChannelæœªè¿æ¥ï¼Œæ— æ³•å‘é€æ¶ˆæ¯', 'error');
            }
        }

        // å›è½¦å‘é€æ¶ˆæ¯
        document.getElementById('messageInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                sendMessage();
            }
        });

        // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', function() {
            updateStatus();
            log('Webå®¢æˆ·ç«¯åˆå§‹åŒ–å®Œæˆ', 'info');
            log(`è®¾å¤‡ID: ${DEVICE_ID}`, 'info');
            log(`æœåŠ¡å™¨åœ°å€: ${SERVER_URL}`, 'info');
        });
    </script>
</body>
</html>
